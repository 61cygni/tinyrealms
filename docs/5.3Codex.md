# 5.3 Codex Architecture Critique

This document reviews the architecture and design choices of this codebase with one goal in mind:

> Keep a persistent world live for years, while evolving it safely with AI-assisted development.

The findings are prioritized by risk to persistence, integrity, and operability.

---

## What I Changed In This Pass

- Added this critique document: `docs/5.3Codex.md`
- Implemented critical auth hardening for profile/gameplay/admin/migration surfaces:
  - `convex/profiles.ts`: ownership checks added to `get`, `savePosition`, `recordNpcChat`, `updateStats`, `addItem`, `removeItem`, `resetMap`, `remove`
  - `convex/profiles.ts`: direct `profiles.setRole` now disabled (must use admin flow)
  - `convex/worldItems.ts`: `pickup` now requires authenticated ownership of `profileId`
  - `convex/chat.ts`: `send` now requires authenticated ownership of `profileId` and uses canonical `profile.name`
  - `convex/presence.ts`: `update` / `remove` now require authenticated ownership of `profileId`
  - `convex/admin.ts`: sensitive queries/mutations now require `adminKey`
  - `convex/admin.ts`: added `admin.removeProfile` for key-based profile deletion (for scripts)
  - `convex/migrations.ts`: all migration/audit functions now require `adminKey`
  - `scripts/manage-users.mjs`: now requires `ADMIN_API_KEY` and passes it automatically
  - `scripts/admin-run.mjs`: new helper wrapper for key-protected admin/migration commands
  - `scripts/dump-state.mjs`: now requires `ADMIN_API_KEY`
- Implemented next-highest integrity fixes:
  - `convex/maps.ts`: map delete now cascades to `worldItems` and map-scoped `messages`
  - `convex/worldItems.ts`: `bulkSave` changed from full-replace to upsert/delete-by-sourceId, preserving pickup/respawn state on existing rows
  - `src/editor/MapEditorPanel.ts`: world item saves now send `sourceId` to support state-preserving upserts
  - `src/engine/Game.ts`: map object/world item live subscription reloads now skip in build mode to avoid clobbering unsaved editor drafts
- Implemented part of operability item:
  - Added CI workflow: `.github/workflows/ci.yml` (typecheck, lint, build)
  - Added backup automation helper: `scripts/backup-world.mjs` (+ `npm run backup:world`)
  - Added safe selective restore path:
    - `scripts/restore-world.mjs` (table-by-table restore, dry-run, confirmation gate, chunked writes)
    - `convex/admin.ts`: `restoreClearTable` + `restoreInsertChunk` (admin-key protected, allowlisted tables only)
    - `package.json`: `npm run restore:world`
  - Added restore verification report output:
    - before/after counts + SHA-256 table hashes
    - report written to `dumps/restore-report-<timestamp>.json`
  - Added dedicated ops runbook: `docs/Operations.md`

### Implementation Status (Top 5)

- [x] Enforce auth/ownership on all profile/admin/migration mutation surfaces
- [x] Make map deletion fully cascading (no orphan state)
- [x] Replace world-item bulk replace with state-preserving upsert
- [x] Protect build-mode drafts from live subscription overwrites
- [x] Add restore path + automated backups + CI smoke tests  
      (implemented: CI workflow, backup helper, selective restore workflow + verification reports)

### Selective Restore Notes

- Command: `npm run restore:world -- --in <dump.json> --tables maps,itemDefs --dry-run`
- Execute writes: add `--confirm` and type `RESTORE` when prompted.
- Current allowlisted restore tables:
  - `maps`, `spriteDefinitions`, `npcProfiles`, `mapObjects`, `itemDefs`, `worldItems`, `messages`
- Safety sanitization during restore:
  - strips `_id` / `_creationTime`
  - strips unsafe cross-deployment ID refs on selected tables (e.g. `createdBy`, `pickedUpBy`, `profileId`)

---

## Executive Summary

The project has strong foundations:

- Clear separation of rendering layers and Convex state
- Good auth scaffolding with profile ownership and superuser model
- Live subscription workflow already in place
- Documentation mindset is strong (`Auth.md`, `EvolvingTheWorld.md`)

The biggest long-term risks are:

1. Missing auth/ownership checks on some backend mutations (critical)
2. Dangerous admin/migration endpoints not fully locked down (critical)
3. Data integrity gaps on map/world-item lifecycle (orphans, state reset) (high)
4. State-sync complexity between editor drafts and live subscriptions (high)
5. Operational gaps: restore path, automated backups, observability, CI/tests (medium-high)

---

## Severity-Ranked Findings

## Critical

- `convex/profiles.ts`: Several mutations patch profile records by `id` without strong ownership checks (`savePosition`, `recordNpcChat`, `updateStats`, `addItem`, `removeItem`, and especially `setRole`).
- `convex/admin.ts`: Multiple destructive mutations are callable without strict superuser gating.
- `convex/migrations.ts`: Generic table/field mutations are powerful and should be internal-only or strictly admin-only.

**Why this matters:** Any auth gap in a persistent world can become irreversible corruption (privilege escalation, mass deletes, silent tampering).

**What I’d do first:**

1. Enforce `getAuthUserId` + ownership checks in every profile mutation.
2. Remove/lock direct `profiles.setRole`; route role changes through a guarded admin path only.
3. Require superuser on all admin/destructive mutations.
4. Convert generic migration operations to `internalMutation` where possible.

## High

- `convex/maps.ts`: Map deletion does not consistently cascade all related entities (e.g., world items/messages risk orphaning).
- `convex/worldItems.ts` + editor save flow: bulk replacement can reset picked-up/respawn state.
- String foreign keys (`mapName`, `itemDefName`, `spriteDefName`) still create rename/delete fragility.
- `src/engine/Game.ts`: monolithic responsibility (~everything in one class) increases regression risk for live updates.
- Subscriptions vs editor draft state can conflict; unsaved build changes can be overwritten by live updates.

**Why this matters:** World state can drift or be lost even when features “work” in single-user testing.

**What I’d do next:**

1. Make map deletion fully cascading and explicit.
2. Replace world-item full-replace save with patch/upsert semantics preserving runtime state.
3. Add orphan-audit queries and run them regularly.
4. Add a build-mode subscription guard (or draft/commit model) for map editing.
5. Begin splitting `Game.ts` into managers (`MapManager`, `PresenceManager`, `SubscriptionManager`).

## Medium

- Ops maturity gaps: no restore script for dumps, manual backups, limited structured monitoring.
- No formal CI regression suite (lint-only workflow is too weak for long-lived live state).
- Some schema/code legacy mismatch across less-used “players/mechanics/story” paths.
- Many constants and cross-file assumptions are still implicit (spawn labels, respawn defaults, etc.).

**Why this matters:** Operational failures become the main risk over years, not just code bugs.

**What I’d do in parallel:**

1. Add restore tooling for `dump-state` output.
2. Add automated scheduled backup workflow and retention policy.
3. Add CI: typecheck + lint + backend integration smoke tests + minimal e2e.
4. Add structured logs and health checks (presence cleanup, NPC loop, subscription churn).

---

## Architecture Strengths Worth Keeping

- Convex-first persistence model is a good fit for “always-live world.”
- Separation of gameplay surfaces (`MapRenderer`, `ObjectLayer`, `EntityLayer`, `WorldItemLayer`) is clean.
- Superuser + map creator ownership model is directionally correct.
- The team already uses migration/backfill thinking and writes docs as part of feature delivery.

---

## 90-Day Practical Roadmap

## Days 1-14 (Hardening)

- Lock all admin + migration + profile role mutation auth paths
- Add consistent ownership checks in profile/gameplay mutations
- Add cascading cleanup for map delete
- Add “orphan audit” queries and run once on current data

## Days 15-45 (State Integrity)

- Refactor world-item save to preserve picked-up/respawn metadata
- Add explicit editor draft mode to prevent subscription overwrite during build
- Add profile live-sync subscription (or periodic refresh on critical transitions)
- Centralize magic constants used by both server/client

## Days 46-90 (Operability + Maintainability)

- Introduce restore script and backup automation
- Add CI pipeline with minimum integration tests
- Split `Game.ts` into smaller managers
- Create “release checklist” + “incident runbook” docs
- Add lightweight observability dashboards/alerts

---

## Specific Design Guidance For AI-Agent Collaboration

- Keep contracts explicit: define typed interfaces between UI/editor/game/Convex layers.
- Minimize “hidden coupling”: if two systems share behavior, move constants and adapters into shared modules.
- Avoid broad generic mutations in production paths; prefer narrow, typed, auditable mutations.
- Treat migrations like code releases: versioned, repeatable, and role-gated.
- Preserve docs as source-of-truth but add a short “Reality Check” section per doc listing what is intentionally deferred.

---

## If I Had To Pick Only 5 Changes

1. Enforce auth/ownership on all profile/admin/migration mutation surfaces.
2. Make map deletion fully cascading (no orphan state).
3. Replace world-item bulk replace with state-preserving upsert.
4. Protect build-mode drafts from live subscription overwrites.
5. Add restore path + automated backups + CI smoke tests.

These five changes alone will significantly reduce the odds of irreversible world-state loss over years.
